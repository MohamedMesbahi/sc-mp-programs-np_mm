;TITLE SCMPKB,	'P005235A 7/14/75' 

	RAM	=	OFOO
	DISP	=	0D00

	;	SEGMENT ASSIGNMENTS

	SA	=
	SB	=

	SA	=	1
	SB	=	2
	SC	=	4
	SD	=	8
	SE	=	16
	SF	=	32
	SG	=	64

	;	7 SEGMENT CONVERSION

	NO	=	SA+SB+SC+SD+SE+SF
	N1	=	SB+SC
	N2	=	SA+SB+SD+SE+SG
	N3	=	SA+SB+SC+SD+SG
	N4	=	SB+SC+SF+SG
	N5	=	SA+SC+SD+SF+SG
	N6	=	SA+SC+SD+SE+SF+SG
	N7	=	SA+SB+SC
	N8	=	SA+SB+SC+SD+SE+SF+SG
	N9	=	SA+SB+SC+SF+SG
	NA	=	SA+SB+SC+SE+SF+SG
	NB	=	SC+SD+SE+SF+SG
	NC	=	SA+SD+SE+SF
	ND	=	SB+SC+SD+SE+SG
	NE	=	SA+SD+SE+SF+SG
	NF	=	SA+SE+SF+SG
	DASH	=	SG
	KE	=	NE
	KR	=	SE+SG
	KO	=	SC+SD+SE+SG

	.PAGE	'HARDWARE FOR KEYBOARD'

	P1H	=	0FF9
	P1L	=	OFFA
	P2H	=	0FFB
	P2L	=	0FFC
	A	=	0FFD
	E	=	0FFE
	S	=	0FFF

		.PAGE 'INITIALIZE'
		NOP
INIT:		JMP        START

GOOUT:
		LD	ADH(2)	;GET GO ADDRESS
		XPAH	3
		LD    	ADL(2)
		XPAL	3
		LD    	@-1(3)	;FIX GO ADDRESS
		LD	E	;RESTORE REGISTERS
		XAE
		LD	P1L
		XPAL	1
		LD	P1H
		XPAH	1
		LD	P2L
		XPAL	2
		LD	P2H
		XPAH	2
		LD	S
		CAS
		LD	A
		XPPC	3	;TO BET BACK 
				;ENTRY POINT FOR DEBUG

START:		ST	A	;SAVE STATUS
		LDE
		ST     	E
		CSA
		ST 	S
		XPAH	1
		ST     	P1H
		XPAL   	1
		ST     	P1L
		LDI	H(RAM)	;SET P2 TO POINT TO RAM
		XPAH  	2
		ST    	P2H
		LDI    	L(RAM)
		XPAL   	2	
		ST     	P2L
		LD     	@1(3)	;BUMP P3 FOR RETURN
		XPAL 	3 	;SAVEp3
		ST     	ADL(2)
		XPAH 	3
    		ST     	ADH(2)

 		.PAGE

	;	ABORT SEQUENCE

ABORT:	LDI	0
	ST	D3(2)
	ST	D4(2)
	ST	D9(2)
	LDI	DASH	;SET SEGMENTS TO -
	ST	DL(2)
	ST	DH(2)
	ST	ADDLL(2)
	ST	ADLH(2)
	ST	ADHL(2)
	ST	ADHH(2)

WAIT:	JS	3,KYBD	;DISPLAY AND READ KEYBOARD

	JMP	WCK	;COMMAND RETURN
	JMP	ABORT	;RETURN FOR NUMBER

WCK:	XRI	07	;CHECK IF MEM
	JZ	MEM
	XRI	01	;CHECK IF GO
	JNZ	ABORT

	.PAGE 'GO TO'

GO:	LDI	-1	;SET FIRST FLAG
	ST	DDTA(2)
	LDI	DASH	;SET DATA TO DASH
	ST	DL(2)
	ST	DH(2)

GOL:	LDI	L(DISPA)-1	;FIX ADDRESS SEG
	XPAL	3
	XPPC	3
	JMP	GOL	;NOT DONE

GOCK:	XRI	03	;CHECK FOR TERM
	JZ	GOOUT	;ERROR IF NO TERM

ERROR:	LDI	KE	;FILL WITH ERROR
	ST	ADHH(2)
	LDI	KR
	ST	ADHL(2)
	ST	ADLH(2)
	ST	D4(2)
	LDI	KO
	ST	ADLL(2)
	LDI	0
	ST	D3(2)
	ST	DH(2)
	ST	DL(2)
	JMP	WAIT

	.PAGE 'MEMORY TRANSACTIONS'

DTACK:	LD	NEXT(2)	;CHECK IF DATA FIELD
	JNZ	DATA	;ADDRESS DONE

MEMDN:	LD	ADH(2)	;PUT WORD IN MEM
	XPAH	1
	LD	ADL(2)
	XPAL	1
	LD	WORD(2)
	ST	(1)
	JMP	MEM

MEMCK:	XRI	06	;CHECK FOR GO
	JZ	ERROR	;CAN NOT GO NOW
	XRI	05	;CHECK FOR TERM
	JZ	DTACK	;CHECK IF DONE
	ILD	ADL(2)	;UPDATE ADDRESS LOW
	JNZ	MEM	;CHECK IF UPDATE HI
	ILD 	ADH(2)

MEM:	LDI	-1	;SET FIRST FLAG
	ST	NEXT(2)	;SET FLAG FOR ADDRESS NOW
	ST	DDTA(2)

MEML:	LD	ADH(2)
	XPAH	1	;SET P1 FOR MEM ADDRESS
	LD	ADL(2)
	XPAL	1
	LD	(1)
	ST	WORD(2)	;SAVE MEM DATA
	LDI	L(DISPD)-1	;FIX DATA SEG
	XPAL	3
	XPPC	3	;GO TO DISPD SET SEG FOR DATA
	JMP	MEMCK	;COMMAND RETURN
	LDI 	L(ADR)-1	;MAKE ADDRESS
	XPAL	3
	XPPC	3
	JMP	MEML	;GET NEXT CHAR

DATA:	LDI	-1	;SET FIRST FLAG
	ST	DDTA(2)
	LD	ADH(2)	;SET P1 TO MEMORY ADDRESS
	XPAH	1	275
	LD	ADL(2)
	XPAL	1
	LD	(1)	;READ DATA WORD
	ST	WORD(2)	;SAVE FOR DISPLAY
	
	.PAGE

DATAL:	LDI 	L(DISPD)-1	;FIX DATA SEG
	XPAL	3
	XPPC	3	;FIX DATA SEG-GO TO DISPD
	JMP	MEMCK	;CHAR RETURN
	LDI	4	;SET COUNTER FOR NUMBER OF SHIFTS	
	ST	CNT(2)
	ILD	DDTA(2)	;CHECK IF FIRST
	JNZ	DNFST
	LDI	0	;ZERO WORD IF FIRST
	ST	WORD(2)
	ST	NEXT(2)	;SET FLAG FOR ADDRESS DONE
	
DNFST:	CCL
	LD	WORD(2)	;SHIFT LEFT
	ADD	WORD(2)
	ST	WORD(2)
	DLD	CNT(2)	;CHECK FOR 4 SHIFTS
	JNZ	DNFST
	LD	WORD(2)	;ADD NEW DATA
	
	LD	WORD(2)	;ADD NEW DATA
	ORE
	ST	WORD(2)
	JMP	DATAL
	JMP	DATAL
	
	.PAGE 'HEX NUMBBER TO SEGMENT TABLE'

CROM:	.BYTE	N0
	.BYTE	N1
	.BYTE	N2
	.BYTE	N3
	.BYTE	N4
	.BYTE	N5
	.BYTE	N6


	.BYTE	N6
	.BYTE	N7
	.BYTE	N8
	.BYTE	N9
	.BYTE	NA
	.BYTE	NB
	.BYTE	NC
	.BYTE	ND
	.BYTE	NE
	.BYTE	NF

	.PAGE 'MAKE 4 DIGIT ADDRESS'

	;	SHIFT ADDRESS LEFT ONE DIGIT THEN

ADR:	LDI	4	;SET NUMBER OF SHIFTS
	ST	CNT(2)
	ILD	DDTA(2)	;CHECK IF FIRST
	JNZ	NOTFST	;JMP IF NO
	LDI	0
	ST	ADH(2)
	ST	ADL(2)

NOTFST:	CCL		;CLEAR LINK
	LD	ADL(2)	;SHIFT ADDRESS LEFT 4 TIMES
	ADD	ADL(2)
	ST	ADL(2)	;SAVE IT
	LD	ADH(2)	;NOW SHIFT HIGH
	ADD	ADH(2)
	ST	ADH(2)
	DLD	CNT(2)	;CHECK IF SHIFTED 4 TIMES
	JNZ	NOTFST	;JMP IF NOT DONE
	LD	ADL(2)	;NOW ADD NEW NUMBER
	ORE
	ST	ADL(2)	;NUMBER IS NOW UP DATED
	XPPC	3

	.PAGE 'DATA TO SEGMENTS'

DISPD:	LDI	H(CROM)	;SET ADDRESS OF TABLE
	XPAH	1
	LDI	L(CROM)
	XPAL	1
	LD	WORD(2)	;GET MEMORY WORD
	ANI	0F
	XAE
	LD	-128(1)	;GET SEGMENT DISP
	ST	DL(2)	;SAVE AT DATA LOW
	LD	WORD(2)	;FIX HI
	SR		;SHIFT HI TO LOW
	SR
	SR
	SR
	XAE
	LD	-128(1)	;GET SEGMENTS
	ST	DH(2)	; SAVE IN DATA HI
	
	.PAGE	ADDRESS TO SEGMENTS
	
DISPA:	SCL
	LDI	H(CROM)	;SET ADDRESS OF TABLE
	XPAH	1
	LDI	L(CROM)
	XPAL	1
LOOPD:	LD	ADL(2)	;GET ADDRESS
	ANI 	0F
	XAE
	LD	-128(1)	;GET SEGMENTS
	ST	ADLL(2)	;SAVE SEG OF ADR LL
	LD	ADL(2)
	SR		;SHIFT HI DIGIT TO LOW
	SR
	SR
	SR
	XAE
	LD	-128(1)	;GET SEGMENTS
	ST	ADLH(2)
	CSA		;CHECK IF DONE
	ANI	080
	JZ	DONE
	CCL		;CLEAR FLAG
	LDI	0
	ST	D4(2)	;ZERO DIGIT 4
	LD	@2(2)	;FIX P2 FOR NEXT LOOP
	JMP	LOOPD
	
DONE:	LD	@-2(2)	;FIX P2
	
	.PAGE 'DISPLAY AND KEYBOARD INPUT'

KYBD:	LDI	0	;ZERO CHAR
	ST	CHAR(2)
	LDI	H(DISP)	;SET DISPLAY ADDRESS
	XPAH	1

OFF:	LDI	-1	;SET ROW/DIGIT ADDRESS
	ST	ROW(2)	;SAVE ROW COUNTER
	LDI	10	;SET ROW COUNT
	ST	CNT(2)
	LDI	0
	ST	PUSHED(2)	;ZERO KEYBOARD INPUT
	XPAL	1	;SET DISP ADDRESS LOW

LOOP:	ILD	ROW(2)	;UP DATE ROW ADDRESS
	XAE
	LD	-128(2)	;GET SEGMENT
	ST	-128(1)	;SEND IT
	DLY	0	;DELAY FOR DISPLAY
	LD	-128(1)	;GET KEYBOAR INPUT
	XRI	OFF	;CHECK IF PUSHED
	JNZ	KEY	;JUMP IF PUSHED

BACK:	DLD	CNT(2)	;CHECK IF DONE
	JNZ 	LOOP	;NO IF JUMP
	LD	PUSHED(2)	;CHECK IF KEY
	JZ	CKMORE
	LD	CHAR(2)	;WAS THERE A CHAR>
	JNZ	OFF	;YES WAIT FOR RELEASE
	LD	PUSHED(2)	;NO SET CHAR
	ST	CHAR(2)
	JMP	OFF	

CKMORE:	LD	CHAR(2)	;CHECK IF THERE WAS A CHAR
	JZ	OFF	;NO KEEP LOOKING
	
	.PAGE

	;	COMMAND KEY PROCESSING

COMMAND:
	XAE		;SAVE CHAR
	LDE		;GET CHAR
	ANI	020	;CHECK FOR COMMAND
	JNZ	CMND	;JUMP IF COMMAND
	LDI	080	;FIND NUMBER
	ANE
	JNZ	LT7	;0 TO 7
	LDI	040
	ANE
	JNZ	N89	;8 OR 9
	LDI	0F
	ANE
	ADI	7	;MAKE OFF SET TO TABLE
	XAE		;PUT OFF SET AWAY
	LD	-128(0)	;GET NUMBER
KEYRTN:	XAE		;SAVE IN E
	LD	@2(3)	;FIX RETURN
	XPPC	3	;RETURN
	JMP	KYBD	;ALLOWS XPPC P3 TO RETURN
	
	.BYTE	0A, 0B, 0C, 0D, 0, OE, 0F

LT7:	XRE		;KEEP LOW DIGIT
	JMP	KEYRTN

N89:	XRE		;GET LOW
	ADI	08	;MAKE DIGIT 8 OR 9
	JMP	KEYRTN

	.PAGE

CMND:	XRE
	XRI 04		;CHECK IF ABORT
	JZ ABRT		;ABORT
	XPPC	3	;IN E 23=MEM, 22=GO, 27=TERM
			;IN A 7=MEM, 6=GO, 3=TERM
	JMP	KYBD	;ALLOWS JUST A XPPC P3 TO RETURN
	
KEY:	ORE		;MAKE CHAR
	ST	PUSHED(2)	;SAVE CHAR
	JMP	BACK

ABRT:	LDI	H(ABORT)
	XPAH	3
	LDI	L(ABORT)-1
	XPAL	3
	XPPC	3	;GO TO ABORT

	.PAGE	'RAM	SE0FF-

	DL	=	0	;SEGMENT FOR DIGIT 1
	DH	=	1	;SEGMENT FOR DIGIT 2
	D3	=	2	;SEGMENT FOR DIGIT 3
	D4	=	3	;SEGMENT FOR DIGIT 4
	ADLL	=	4	;SEGMENT FOR DIGIT 5
	ADLH	=	5	;SEGMENT FOR DIGIT 6
	ADHL	=	6	;SEGMENT FOR DIGIT 7
	ADHH	=	7	;SEGMENT FOR DIGIT 8
	D9	=	8	;SEGMENT FOR DIGIT 9
	CNT	=	9	;COUNTER
	PUSHED	=	10	KEY PUSHED
	CHAR	11

	CHAR	=	11	;CHAR READ
	ADL	=	12	;MEMORY ADDRESS LOW
	WORD	=	13	;MEMORY WORD
	ADH	=	14	;MEMORY ADDRESS HI
	=	=	15	;FIRST FLAG
	ROW	=	16	;ROW COUNTER
	NEXT	=	17	;FLAG FOR NOW DATA

		.END
